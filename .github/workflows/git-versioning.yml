name: CI/CD with Versioning and Auto-Merge

on:
  pull_request:
    branches:
      - develop

jobs:
  versioning_and_merge:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

# Install requirements
      - name: Install jq
        run: sudo apt-get install -y jq

# Get the latest tag
      - name: Get Latest Tag using GitHub API
        id: get_latest_tag
        run: |
          # Fetch the latest tag from GitHub API
          latest_tag=$(curl -H "Authorization: token ${{ secrets.MY_GITHUB_TOKEN }}" \
                            -H "Accept: application/vnd.github.v3+json" \
                            "https://api.github.com/repos/${{ github.repository }}/tags" \
                            | jq -r '.[0].name')

          # Parse the MAJOR, MINOR, and PATCH versions from the tag
          if [[ $latest_tag =~ ([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            major_version="${BASH_REMATCH[1]}"
            minor_version="${BASH_REMATCH[2]}"
            patch_version="${BASH_REMATCH[3]}"
          else
            echo "Failed to parse the latest tag version."
            exit 1
          fi

          echo "major_version=$major_version" >> $GITHUB_ENV
          echo "minor_version=$minor_version" >> $GITHUB_ENV
          echo "patch_version=$patch_version" >> $GITHUB_ENV
        shell: bash

# Versioning strategy based on PR labels
      - name: Fetch PR Labels or Base Branch
        id: fetch_pr_info
        run: |
          pr_number=$(jq --raw-output .pull_request.number "$GITHUB_EVENT_PATH")
          base_ref=$(jq --raw-output .pull_request.base.ref "$GITHUB_EVENT_PATH")
          labels=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/issues/$pr_number/labels" \
          | jq -r 'map(.name) | join(",")')
          
          if [ -z "$labels" ]; then
            echo "Using base_ref for versioning: $base_ref"
            echo "base_ref=$base_ref" >> $GITHUB_ENV
          else
            echo "Using PR Labels for versioning: $labels"
            echo "pr_labels=$labels" >> $GITHUB_ENV
          fi
        shell: bash

# Calculate and display new version
      - name: Calculate and Display New Version
        id: calculate_version
        run: |
          MAJOR=${{ env.major_version }}
          MINOR=${{ env.minor_version }}
          PATCH=${{ env.patch_version }}
          pr_labels=${{ env.pr_labels }}
          base_ref=${{ env.base_ref }}
          
          set +e  # Allow non-zero exit code for the next commands
          
          if [[ "$pr_labels" == *"major"* || "$base_ref" == "feature/major"* ]]; then
            ((MAJOR++))
            MINOR=0
            PATCH=0
          elif [[ "$pr_labels" == *"feature"* || "$base_ref" == "feature/"* ]]; then
            ((MINOR++))
            PATCH=0
          elif [[ "$pr_labels" == *"bugfix"* || "$base_ref" == "bugfix/"* ]]; then
            ((PATCH++))
          fi

          set -e  # Revert to default behavior of failing on non-zero exit code

          new_version="v$MAJOR.$MINOR.$PATCH"
          echo "New Version: $new_version"
        shell: bash

# Predictive versioning based on open PRs
      - name: Fetch Open PRs and Predict Next Version
        id: debug_predict_next_version
        run: |
          # Fetch all open PRs against 'develop'
          open_prs=$(curl -s -H "Authorization: token ${{ secrets.MY_GITHUB_TOKEN }}" \
                          "https://api.github.com/repos/${{ github.repository }}/pulls?state=open&base=develop" \
                    | jq -r '.[] | .labels[].name')

          # Initialize counters for feature and bugfix PRs
          feature_count=0
          bugfix_count=0

          # Tally up the features and bugfixes
          for label in $open_prs; do
            if [[ "$label" == "feature" ]]; then
              ((feature_count++))
            elif [[ "$label" == "bugfix" ]]; then
              ((bugfix_count++))
            fi
          done

          # Predict the next version based on the tallied features and bugfixes
          next_minor=$(( MINOR + feature_count ))
          next_patch=$(( PATCH + bugfix_count ))

          # Display the predicted next version for debugging
          predicted_version="v$MAJOR.$next_minor.$next_patch"
          echo "Predicted Next Version (if all open PRs are merged): $predicted_version"
        shell: bash
        